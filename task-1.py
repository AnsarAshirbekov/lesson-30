# Создайте декоратор, который будет засекать время перед выполнением декорируемой функции и 
# затем выводить на экран сколько времени заняло ее выполнение

# Декоратор - это функция, которая принимает в качестве аргумента другую функцию. 
# Он нужен для добавления дополнительного функционала для той функции, к которой мы хотим его применить, 
# не изменяя при этом саму функцию. Внутри декоратора создается еще функция (wrapper), внутри которой прописывается 
# дополнительный функционал и происходит вызов оригинальной функции, результат которой записывается в какую-нибудь 
# переменную (result). Затем этот результат возвращается и возвращается сама внутренняя функция декоратора. 
# Чтобы применить к функции декоратор, нужно прописать его название перед самим созданием функции с @ 
# и тогда при вызове этой функции она будет уже задекорирована.

import time
# создаем декоратор, в качестве аргумента будет какая-нибудь функция
def time_measurement(function):
    # внутри декоратора создаем функцию обертки, которая будет принимать такие же аргументы, как и та функция, к которой
    # мы собираемся применить декоратор
    def wrapper(*args, **kwargs):
        # прописываем функционал декоратора
        start = time.time()
        # вызываем оригинальную функцию с ее аргументами и записываем в переменную
        result = function(*args, **kwargs)
        end = time.time()
        print(f'Время, потраченное на выполнение функции, составляет: {end - start} секунд')
        # возвращаем результат оригинальной функции
        return result
    # вызываем внутреннюю функцию декоратора
    return wrapper

# Чтобы обернуть функцию в декоратор, нужно перед ее созданием прописать название декоратора с @
@time_measurement
def time_counting(number: int):
    for i in range(1, number + 1):
        print(i)

# вызовем оригинальную функцию
time_counting(50)
# Когда происходит вызов задекорированной функции, выполняются сначала действия внутренней функции декоратора, а не 
# оригинальной функции, то есть вместо time_counting встает wrapper, но внутри него уже будет вызываться time_counting
# и возвращать свой результат